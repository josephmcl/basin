#pragma once
/* linalg.h is intended to encapsulate capabilities common to several 
   different linear algebra libraries, allowing different libraries to 
   to arbitrarily swapped out with ease. */


/* stl headers */
#include <type_traits>

/* petsc headers */
#include "mkl.h"



namespace linalg {

  using namespace oneapi::mkl;

  /* framework enumerates the supported linear algebra paradigms. For 
     now this only supports PETSc. */
  enum class framework : std::size_t {
    petsc = 0
    mkl = 1
  };

  /* STL type aliases. */
  using st = std::size_t;

  /* PETSc type aliases. */
  using mkl_matrix = Mat;
  // using mkl_vector = Vec;

  /* Evaluate the back-end linalg matrix type at compile time. Idea 
     robbed from stackoverflow.com/a/61177390 */
  template<framework f>
  constexpr auto pick_matrix_type() {
    if constexpr (f == framework::mkl) {
        return std::type_identity<mkl_matrix>{};
    } 
  }

  /* The compile time matrix type template. */
  template<framework f> using matrix = typename 
  decltype(pick_matrix_type<f>())::type;

  /* Initialize a local sparse matrix. */
  template<framework f>
  inline void make_sparse_matrix(matrix<f> &m, st rows, st cols, st nz) {
    if constexpr (f == framework::mkl)
      MatCreateSeqAIJ(PETSC_COMM_SELF, rows, cols, nz, nullptr, &m);
  }

  /* Finalize a matrix. */
  template<framework f>
  inline void finalize(matrix<f> &m) {
    if constexpr (f == framework::mkl) {
      PetscErrorCode e;
      e = MatAssemblyBegin(m, MAT_FINAL_ASSEMBLY);
      e = MatAssemblyEnd(m,   MAT_FINAL_ASSEMBLY);
    }
  }

  /* Destroy a matrix. */
  template<framework f>
  inline void destroy(matrix<f> &m) {
    if constexpr (f == framework::mkl) MatDestroy(&m);
  }